#!/usr/bin/env python3
"""
CI/CD Secrets Injection Script
Automatically injects secrets from environment variables into application config files
Works with GitHub Actions, Railway, and other CI/CD platforms
"""

import os
import json
from pathlib import Path
from typing import Dict, Any, List


def get_github_secrets() -> Dict[str, str]:
    """Extract GitHub Actions secrets from environment"""
    secrets = {}
    
    # Common GitHub secrets
    github_vars = [
        'GITHUB_TOKEN',
        'RAILWAY_TOKEN',
        'SECRET_KEY',
        'JWT_SECRET',
        'SESSION_SECRET',
        'DATABASE_URL',
        'REDIS_URL',
        'NDAX_API_KEY',
        'NDAX_API_SECRET',
        'STRIPE_API_KEY',
        'STRIPE_SECRET_KEY',
        'AWS_ACCESS_KEY_ID',
        'AWS_SECRET_ACCESS_KEY',
        'HUGGINGFACE_API_KEY',
        'DISCORD_WEBHOOK_URL',
    ]
    
    for var in github_vars:
        value = os.getenv(var)
        if value:
            secrets[var] = value
            print(f"  âœ… Found: {var}")
    
    return secrets


def get_railway_secrets() -> Dict[str, str]:
    """Extract Railway secrets from environment"""
    secrets = {}
    
    # Railway provides these automatically
    railway_vars = [
        'RAILWAY_ENVIRONMENT',
        'RAILWAY_PROJECT_ID',
        'RAILWAY_SERVICE_ID',
        'RAILWAY_DEPLOYMENT_ID',
        'PORT',  # Railway sets this
    ]
    
    for var in railway_vars:
        value = os.getenv(var)
        if value:
            secrets[var] = value
            print(f"  âœ… Railway: {var}")
    
    return secrets


def inject_env_file(secrets: Dict[str, str], env_path: Path) -> bool:
    """Inject secrets into .env file"""
    print(f"\nğŸ“ Injecting secrets into {env_path}")
    
    # Read existing .env or create new
    existing = {}
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    existing[key] = value
    
    # Merge with secrets (secrets take precedence)
    merged = {**existing, **secrets}
    
    # Write updated .env
    with open(env_path, 'w') as f:
        f.write("# Auto-generated by CI/CD secrets injection\n")
        f.write("# DO NOT COMMIT THIS FILE\n\n")
        
        for key, value in sorted(merged.items()):
            f.write(f"{key}={value}\n")
    
    # Set secure permissions
    try:
        os.chmod(env_path, 0o600)
        print(f"  âœ… Set permissions to 600")
    except Exception as e:
        print(f"  âš ï¸  Could not set permissions: {e}")
    
    print(f"  âœ… Wrote {len(merged)} variables")
    return True


def inject_credentials_json(secrets: Dict[str, str], creds_path: Path) -> bool:
    """Inject secrets into credentials.json"""
    print(f"\nğŸ“ Injecting secrets into {creds_path}")
    
    # Load template if exists
    template_path = creds_path.parent / 'credentials.template.json'
    
    if template_path.exists():
        with open(template_path, 'r') as f:
            credentials = json.load(f)
    else:
        credentials = {}
    
    # Map environment variables to credential structure
    mappings = {
        'NDAX_API_KEY': ['exchanges', 'ndax', 'api_key'],
        'NDAX_API_SECRET': ['exchanges', 'ndax', 'api_secret'],
        'STRIPE_API_KEY': ['payment_processors', 'stripe', 'api_key'],
        'STRIPE_SECRET_KEY': ['payment_processors', 'stripe', 'secret_key'],
        'DATABASE_URL': ['database', 'postgresql', 'url'],
        'REDIS_URL': ['database', 'redis', 'url'],
        'DISCORD_WEBHOOK_URL': ['notifications', 'discord', 'webhook_url'],
    }
    
    # Inject secrets into nested structure
    updated_count = 0
    for env_var, path_parts in mappings.items():
        if env_var in secrets:
            # Navigate to nested location
            current = credentials
            for part in path_parts[:-1]:
                if part not in current:
                    current[part] = {}
                current = current[part]
            
            # Set value and enable
            current[path_parts[-1]] = secrets[env_var]
            if 'enabled' in current:
                current['enabled'] = True
            
            updated_count += 1
            print(f"  âœ… Injected: {'.'.join(path_parts)}")
    
    # Write credentials file
    if updated_count > 0:
        with open(creds_path, 'w') as f:
            json.dump(credentials, f, indent=2)
        
        # Set secure permissions
        try:
            os.chmod(creds_path, 0o600)
            print(f"  âœ… Set permissions to 600")
        except Exception as e:
            print(f"  âš ï¸  Could not set permissions: {e}")
        
        print(f"  âœ… Updated {updated_count} credentials")
        return True
    else:
        print(f"  â„¹ï¸  No secrets to inject")
        return False


def validate_critical_secrets(secrets: Dict[str, str]) -> List[str]:
    """Validate that critical secrets are present"""
    critical = [
        'SECRET_KEY',
        'JWT_SECRET',
    ]
    
    missing = [s for s in critical if s not in secrets]
    return missing


def main():
    """Main injection function"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Inject CI/CD secrets into application config files'
    )
    parser.add_argument(
        '--env-file',
        default='.env',
        help='Path to .env file (default: .env)'
    )
    parser.add_argument(
        '--credentials-file',
        default='config/credentials.json',
        help='Path to credentials.json (default: config/credentials.json)'
    )
    parser.add_argument(
        '--validate-only',
        action='store_true',
        help='Only validate secrets without writing files'
    )
    args = parser.parse_args()
    
    # Determine paths
    repo_root = Path(__file__).parent.parent
    env_path = repo_root / args.env_file
    creds_path = repo_root / args.credentials_file
    
    print("=" * 60)
    print("ğŸ” CI/CD SECRETS INJECTION")
    print("=" * 60)
    print(f"ğŸ“ Repository: {repo_root}")
    print()
    
    # Detect CI/CD platform
    if os.getenv('GITHUB_ACTIONS'):
        print("ğŸ—ï¸  Platform: GitHub Actions")
        platform = 'github'
    elif os.getenv('RAILWAY_ENVIRONMENT'):
        print("ğŸš‚ Platform: Railway")
        platform = 'railway'
    else:
        print("ğŸ’» Platform: Local/Unknown")
        platform = 'local'
    
    print()
    print("ğŸ” Extracting secrets from environment...")
    
    # Get secrets based on platform
    secrets = {}
    if platform == 'github':
        secrets.update(get_github_secrets())
    elif platform == 'railway':
        secrets.update(get_railway_secrets())
        secrets.update(get_github_secrets())  # Railway can have both
    else:
        secrets.update(get_github_secrets())  # Try GitHub secrets anyway
    
    print(f"\nğŸ“Š Found {len(secrets)} secrets")
    
    # Validate critical secrets
    missing = validate_critical_secrets(secrets)
    if missing:
        print(f"\nâš ï¸  WARNING: Missing critical secrets:")
        for s in missing:
            print(f"   - {s}")
        print("\nğŸ’¡ These secrets should be set in your CI/CD platform")
    
    if args.validate_only:
        print("\nâœ… Validation complete (no files written)")
        return 0 if not missing else 1
    
    # Inject secrets into files
    success_count = 0
    
    if inject_env_file(secrets, env_path):
        success_count += 1
    
    if inject_credentials_json(secrets, creds_path):
        success_count += 1
    
    # Summary
    print("\n" + "=" * 60)
    print("ğŸ“Š INJECTION SUMMARY")
    print("=" * 60)
    print(f"âœ… Successfully injected: {success_count} files")
    print(f"ğŸ“ Total secrets: {len(secrets)}")
    
    if missing:
        print(f"âš ï¸  Missing critical: {len(missing)}")
        print("\nâš ï¸  WARNING: Application may not start without critical secrets")
        return 1
    else:
        print("\nâœ… All critical secrets present")
        return 0


if __name__ == '__main__':
    exit(main())
